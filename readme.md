# sqlshell

sqlshell is a bare-bones database management system intended for light-weight usage where efficiency is not a prime concern.

![sqlshell in action](https://raw.githubusercontent.com/divkakwani/sqlshell/master/snapshot.png)

### Installation

To build, run:
```
make
```
and to install, run:
```
make install
```


### Internals

The software has, as of now, three components - lexer, parser and an execution engine. Their
functioning is as follows:

* Lexer: It takes the commands from the user via an input stream and converts it into token stream.
         The token objects so produced have an aggregate type (struct). The final output is
         a stream consisting of objects of the form `<token-id, void*>`. The token-id solely determines
         the type of the token and the second field - void* - can be used to pass any data to the
         parser. A multitude of token types are defined in tokentypes.h which are used by the lexer
         for the second field.
         <br> This lexer is generated automatically by the program `flex`.

* Parser: From the token stream supplied by the lexer, it generates an Abstract Syntax Tree (AST).
          Each node in the AST so produced has a type that determines the type of the construct.
          The AST itself is rooted at a node of type stmt_t. The types of its
          children are decided by the grammar.<br>
          It is important to note that although the parser receives a stream of untyped objects
          from the lexer, the token-id field determines the type of the object. In this 
          way, the parser implicitly assumes that the output of the lexer is consistent - if the 
          token-id is x, then the second field must have a type assigned to the token of type x.
          Consquently, these tokenid - tokentypes mapping have to be concurred in advance by both
          the lexer and parser.
          <br> This parser is generated by bison.

* Execution Engine: The execution engine traverses the AST produced by the parser and executes them
                    appropriately. It maintains an exec function for each type of node that is
                    to be invoked when that type of node is encountered. This component handles 
                    all the nitty-gritty details of storage, retrieval, searching etc. of the 
                    databases encapsulated in the exec functions. 
                    <br> Since this component does a lot of task all by itself, it is expected
                    that it would be further split in future.
                    <br> The execution engine is intentionally separated from the parser to make
                    the parser storage independent. With this architecture, the representation of
                    databases can be changed by changing only this component.
